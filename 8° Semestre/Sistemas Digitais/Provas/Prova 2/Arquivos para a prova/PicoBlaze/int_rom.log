KCPSM6 Assembler log file for program 'C:\ProjetosVHDL\KCPSM6\int_rom.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 02 Aug 2022
Assembly timestamp: 14:59:39

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 3FF hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 189
Memory locations available: 3907


Assembly listing

 Addr Code                        Instruction

 000                              ;=========================================================
 000                              ; Square circuit with interrupt interface
 000                              ;=========================================================
 000                              ;Program operation:
 000                              ;  - read a and b from switch
 000                              ;  - calculate a*a + b*b
 000                              ;  - use interrupt to refresh 7-seg led display
 000                              ;=========================================================
 000                              ; Data ram address alias
 000                              ;=========================================================
 000                              CONSTANT a_lsb, 00
 000                              CONSTANT b_lsb, 02
 000                              CONSTANT aa_lsb, 04
 000                              CONSTANT aa_msb, 05
 000                              CONSTANT bb_lsb, 06
 000                              CONSTANT bb_msb, 07
 000                              CONSTANT aabb_lsb, 08
 000                              CONSTANT aabb_msb, 09
 000                              CONSTANT aabb_cout, 0A
 000                              CONSTANT led0, 10
 000                              CONSTANT led1, 11
 000                              CONSTANT led2, 12
 000                              CONSTANT led3, 13
 000                              ;=========================================================
 000                              ; Register alias
 000                              ;=========================================================
 000                              ;commonly used local variables
 000                              NAMEREG s0, data               ;reg for temporary data
 000                              NAMEREG s1, addr               ;reg for temporary mem & i/o port addr
 000                              NAMEREG s2, i                  ;general-purpose loop index
 000                              ;global variables
 000                              NAMEREG sC, switch_a_b         ;ram offset for current switch input
 000                              NAMEREG sB, led_pos            ;led disp position (0, 1, 2 or 3)
 000                              NAMEREG sE, count_msb          ;timer tick count 8 MSBs
 000                              NAMEREG sF, count_lsb          ;timer tick count 8 LSBs
 000                              ;=========================================================
 000                              ; Port alias
 000                              ;=========================================================
 000                              ;------------input port definitions---------------------
 000                              CONSTANT rd_flag_port, 00
 000                              ; 2 flags (xxxxxxsc):
 000                              CONSTANT sw_port, 01           ;8-bit switches
 000                              ;------------output port definitions---------------------
 000                              CONSTANT an_port, 00
 000                              CONSTANT sseg_port, 01
 000                              ;=========================================================
 000                              ; Main program
 000                              ;=========================================================
 000                              ;Calling hierarchy:
 000                              ;
 000                              ;main
 000                              ;  - init
 000                              ;  - proc_btn
 000                              ;      - init
 000                              ;  - proc_uart
 000                              ;  - square
 000                              ;      - mult_soft
 000                              ;  - load_led_pttn
 000                              ;      - get_lower_nibble
 000                              ;      - get_upper_nibble
 000                              ;      - hex_to_led
 000                              ;  - display_mux_out
 000                              ; =========================================================
 000  20006                       CALL 006[init]                 ;initialization
 001                     forever: 
 001                              ;main loop body
 001  20011                       CALL 011[proc_btn]             ;check & process buttons
 002  20083                       CALL 083[square]               ;calculate square
 003  2001E                       CALL 01E[load_led_pttn]        ;store led patterns to ram
 004  200A1                       CALL 0A1[display_mux_out]      ; multiplex led patterns
 005  22001                       JUMP 001[forever]
 006                              ;=========================================================
 006                              ;routine: init
 006                              ;  function: perform initialization, clear register/ram
 006                              ;  output register:
 006                              ;    switch_a_b: cleared to 0
 006                              ;  temp register: data, i
 006                              ;=========================================================
 006                        init: 
 006  28001                       ENABLE INTERRUPT
 007                              ;clear memory
 007  01240                       LOAD s2[i], 40                 ;unitize loop index to 64
 008  01000                       LOAD s0[data], 00
 009                clr_mem_loop: 
 009  2E020                       STORE s0[data], (s2[i])
 00A  19201                       SUB s2[i], 01                  ;dec loop index
 00B  36009                       JUMP NZ, 009[clr_mem_loop]     ;repeat until i=0
 00C                              ;clear registers
 00C  01C00                       LOAD sC[switch_a_b], 00
 00D  01B00                       LOAD sB[led_pos], 00
 00E  01E00                       LOAD sE[count_msb], 00
 00F  01F00                       LOAD sF[count_lsb], 00
 010  25000                       RETURN 
 011                              ;=========================================================
 011                              ;routine: proc_btn
 011                              ;  function: check two buttons and process the display
 011                              ;  input reg:
 011                              ;     switch_a_b: ram offset (0 for a and 2 for b)
 011                              ;  output register:
 011                              ;     s3: store input port flag
 011                              ;     switch_a_b: may be toggled
 011                              ;  temp register used: data, addr
 011                              ;=========================================================
 011                    proc_btn: 
 011  09300                       INPUT s3, 00[rd_flag_port]     ;get flag
 012                              ;check and process c button
 012  0D301                       TEST s3, 01                    ;check c button flag
 013  32016                       JUMP Z, 016[chk_btns]          ;flag not set
 014  20006                       CALL 006[init]                 ;flag set, clear
 015  2201D                       JUMP 01D[proc_btn_done]
 016                    chk_btns: 
 016                              ;check and process s button
 016  0D302                       TEST s3, 02                    ;check s button flag
 017  3201D                       JUMP Z, 01D[proc_btn_done]     ;flag not set
 018  09001                       INPUT s0[data], 01[sw_port]    ;get switch
 019  01100                       LOAD s1[addr], 00[a_lsb]       ;get addr of a
 01A  101C0                       ADD s1[addr], sC[switch_a_b]   ;add offset
 01B  2E010                       STORE s0[data], (s1[addr])     ;write data to ram
 01C                              ;update current disp position
 01C  07C02                       XOR sC[switch_a_b], 02         ;toggle between 00, 02
 01D               proc_btn_done: 
 01D  25000                       RETURN 
 01E                              ;=========================================================
 01E                              ;routine: load_led_pttn
 01E                              ;  function: read 3 LSBs of switch input and convert the
 01E                              ;            desired values to four led patterns and
 01E                              ;            load them to ram
 01E                              ;            switch: 000:a; 001:b; 010:a^2; 011:b^2;
 01E                              ;                    others: a^2 + b^2
 01E                              ;  tmp register used: data, addr
 01E                              ;    s6: data from sw input port
 01E                              ;=========================================================
 01E               load_led_pttn: 
 01E  09601                       INPUT s6, 01[sw_port]          ;get switch
 01F  14606                       SL0 s6                         ;*2 to obtain addr offset
 020  1D608                       COMPARE s6, 08                 ;sw>100?
 021  3A023                       JUMP C, 023[sw_ok]             ;no
 022  01608                       LOAD s6, 08                    ;yes, sw error, make default
 023                       sw_ok: 
 023                              ;process byte 0, lower nibble
 023  01100                       LOAD s1[addr], 00[a_lsb]
 024  10160                       ADD s1[addr], s6               ;get lower addr
 025  0A060                       FETCH s0[data], (s6)           ;get lower byte
 026  2007C                       CALL 07C[get_lower_nibble]     ;get lower nibble
 027  2003E                       CALL 03E[hex_to_led]           ;convert to led pattern
 028  2F010                       STORE s0[data], 10[led0]
 029                              ;process byte 0, upper nibble
 029  0A010                       FETCH s0[data], (s1[addr])
 02A  2007E                       CALL 07E[get_upper_nibble]
 02B  2003E                       CALL 03E[hex_to_led]
 02C  2F011                       STORE s0[data], 11[led1]
 02D                              ;process byte 1, lower nibble
 02D  11101                       ADD s1[addr], 01               ;get upper addr
 02E  0A010                       FETCH s0[data], (s1[addr])
 02F  2007C                       CALL 07C[get_lower_nibble]
 030  2003E                       CALL 03E[hex_to_led]
 031  2F012                       STORE s0[data], 12[led2]
 032                              ;process byte 1, upper nibble
 032  0A010                       FETCH s0[data], (s1[addr])
 033  2007E                       CALL 07E[get_upper_nibble]
 034  2003E                       CALL 03E[hex_to_led]
 035                              ;check for sw=100 to process carry as led dp
 035  1D608                       COMPARE s6, 08                 ;display final result?
 036  3603C                       JUMP NZ, 03C[led_done]         ;no
 037  11101                       ADD s1[addr], 01               ;get carry addr
 038  0A610                       FETCH s6, (s1[addr])           ;s6 to store carry
 039  0D601                       TEST s6, 01                    ;carry=1?
 03A  3203C                       JUMP Z, 03C[led_done]          ;no
 03B  0307F                       AND s0[data], 7F               ;yes, assert msb (dp) to 0
 03C                    led_done: 
 03C  2F013                       STORE s0[data], 13[led3]
 03D  25000                       RETURN 
 03E                              ;=========================================================
 03E                              ;routine: hex_to_led
 03E                              ;  function: convert a hex digit to 7-seg led pattern
 03E                              ;  input register: data
 03E                              ;  output register: data
 03E                              ;=========================================================
 03E                  hex_to_led: 
 03E  1D000                       COMPARE s0[data], 00
 03F  36042                       JUMP NZ, 042[comp_hex_1]
 040  01081                       LOAD s0[data], 81              ;7seg pattern 0
 041  2207B                       JUMP 07B[hex_done]
 042                  comp_hex_1: 
 042  1D001                       COMPARE s0[data], 01
 043  36046                       JUMP NZ, 046[comp_hex_2]
 044  010CF                       LOAD s0[data], CF              ;7seg pattern 1
 045  2207B                       JUMP 07B[hex_done]
 046                  comp_hex_2: 
 046  1D002                       COMPARE s0[data], 02
 047  3604A                       JUMP NZ, 04A[comp_hex_3]
 048  01092                       LOAD s0[data], 92              ;7seg pattern 2
 049  2207B                       JUMP 07B[hex_done]
 04A                  comp_hex_3: 
 04A  1D003                       COMPARE s0[data], 03
 04B  3604E                       JUMP NZ, 04E[comp_hex_4]
 04C  01086                       LOAD s0[data], 86              ;7seg pattern 3
 04D  2207B                       JUMP 07B[hex_done]
 04E                  comp_hex_4: 
 04E  1D004                       COMPARE s0[data], 04
 04F  36052                       JUMP NZ, 052[comp_hex_5]
 050  010CC                       LOAD s0[data], CC              ;7seg pattern 4
 051  2207B                       JUMP 07B[hex_done]
 052                  comp_hex_5: 
 052  1D005                       COMPARE s0[data], 05
 053  36056                       JUMP NZ, 056[comp_hex_6]
 054  010A4                       LOAD s0[data], A4              ;7seg pattern 5
 055  2207B                       JUMP 07B[hex_done]
 056                  comp_hex_6: 
 056  1D006                       COMPARE s0[data], 06
 057  3605A                       JUMP NZ, 05A[comp_hex_7]
 058  010A0                       LOAD s0[data], A0              ;7seg pattern 6
 059  2207B                       JUMP 07B[hex_done]
 05A                  comp_hex_7: 
 05A  1D007                       COMPARE s0[data], 07
 05B  3605E                       JUMP NZ, 05E[comp_hex_8]
 05C  0108F                       LOAD s0[data], 8F              ;7seg pattern 7
 05D  2207B                       JUMP 07B[hex_done]
 05E                  comp_hex_8: 
 05E  1D008                       COMPARE s0[data], 08
 05F  36062                       JUMP NZ, 062[comp_hex_9]
 060  01080                       LOAD s0[data], 80              ;7seg pattern 8
 061  2207B                       JUMP 07B[hex_done]
 062                  comp_hex_9: 
 062  1D009                       COMPARE s0[data], 09
 063  36066                       JUMP NZ, 066[comp_hex_a]
 064  01084                       LOAD s0[data], 84              ;7seg pattern 9
 065  2207B                       JUMP 07B[hex_done]
 066                  comp_hex_a: 
 066  1D00A                       COMPARE s0[data], 0A
 067  3606A                       JUMP NZ, 06A[comp_hex_b]
 068  01088                       LOAD s0[data], 88              ;7seg pattern a
 069  2207B                       JUMP 07B[hex_done]
 06A                  comp_hex_b: 
 06A  1D00B                       COMPARE s0[data], 0B
 06B  3606E                       JUMP NZ, 06E[comp_hex_c]
 06C  010E0                       LOAD s0[data], E0              ;7seg pattern b
 06D  2207B                       JUMP 07B[hex_done]
 06E                  comp_hex_c: 
 06E  1D00C                       COMPARE s0[data], 0C
 06F  36072                       JUMP NZ, 072[comp_hex_d]
 070  010B1                       LOAD s0[data], B1              ;7seg pattern C
 071  2207B                       JUMP 07B[hex_done]
 072                  comp_hex_d: 
 072  1D00D                       COMPARE s0[data], 0D
 073  36076                       JUMP NZ, 076[comp_hex_e]
 074  010C2                       LOAD s0[data], C2              ;7seg pattern d
 075  2207B                       JUMP 07B[hex_done]
 076                  comp_hex_e: 
 076  1D00E                       COMPARE s0[data], 0E
 077  3607A                       JUMP NZ, 07A[comp_hex_f]
 078  010B0                       LOAD s0[data], B0              ;7seg pattern E
 079  2207B                       JUMP 07B[hex_done]
 07A                  comp_hex_f: 
 07A  010B8                       LOAD s0[data], B8              ;7seg pattern f
 07B                    hex_done: 
 07B  25000                       RETURN 
 07C                              ;=========================================================
 07C                              ;routine: get_lower_nibble
 07C                              ;  function: get lower 4-bit of data
 07C                              ;  input register: data
 07C                              ;  output register: data
 07C                              ;=========================================================
 07C            get_lower_nibble: 
 07C  0300F                       AND s0[data], 0F               ;clear upper nibble
 07D  25000                       RETURN 
 07E                              ;=========================================================
 07E                              ;routine: get_lupper_nible
 07E                              ;  function: get upper 4-bit of in_data
 07E                              ;  input register: data
 07E                              ;  output register: data
 07E                              ;=========================================================
 07E            get_upper_nibble: 
 07E  1400E                       SR0 s0[data]                   ;right shift 4 times
 07F  1400E                       SR0 s0[data]
 080  1400E                       SR0 s0[data]
 081  1400E                       SR0 s0[data]
 082  25000                       RETURN 
 083                              ;=========================================================
 083                              ;routine: square
 083                              ;  function: calculate a*a + b*b
 083                              ;     data/result stored in ram started w/ SQ_BASE_ADDR
 083                              ;  temp register: s3, s4, s5, s6, data
 083                              ;=========================================================
 083                      square: 
 083                              ;calculate a*a
 083  0B300                       FETCH s3, 00[a_lsb]            ;load a
 084  0B400                       FETCH s4, 00[a_lsb]            ;load a
 085  20097                       CALL 097[mult_soft]            ;calculate a*a
 086  2F604                       STORE s6, 04[aa_lsb]           ;store lower byte of a*a
 087  2F505                       STORE s5, 05[aa_msb]           ;store upper byte of a*a
 088                              ;calculate b*b
 088  0B302                       FETCH s3, 02[b_lsb]            ;load b
 089  0B402                       FETCH s4, 02[b_lsb]            ;load b
 08A  20097                       CALL 097[mult_soft]            ;calculate b*b
 08B  2F606                       STORE s6, 06[bb_lsb]           ;store lower byte of b*b
 08C  2F507                       STORE s5, 07[bb_msb]           ;store upper byte of b*b
 08D                              ;calculate a*a+b*b
 08D  0B004                       FETCH s0[data], 04[aa_lsb]     ;get lower byte of a*a
 08E  10060                       ADD s0[data], s6               ;add lower byte of a*a+b*b
 08F  2F008                       STORE s0[data], 08[aabb_lsb]   ;store lower byte of a*a+b*b
 090  0B005                       FETCH s0[data], 05[aa_msb]     ;get upper byte of a*a
 091  12050                       ADDCY s0[data], s5             ;add upper byte of a*a+b*b
 092  2F009                       STORE s0[data], 09[aabb_msb]   ;store upper byte of a*a+b*b
 093  01000                       LOAD s0[data], 00              ;clear data, but keep carry
 094  13000                       ADDCY s0[data], 00             ;get carry from previous +
 095  2F00A                       STORE s0[data], 0A[aabb_cout]  ;store carry of a*a+b*b
 096  25000                       RETURN 
 097                              ;=========================================================
 097                              ;routine: mult_soft
 097                              ;  function: 8-bit unsigned multiplier using
 097                              ;           shift-and-add algorithm
 097                              ;  input register:
 097                              ;     s3: multiplicand
 097                              ;     s4: multiplier
 097                              ;  output register:
 097                              ;     s5: upper byte of product
 097                              ;     s6: lower byte of product
 097                              ;  temp register: i
 097                              ;=========================================================
 097                   mult_soft: 
 097  01500                       LOAD s5, 00                    ;clear s5
 098  01208                       LOAD s2[i], 08                 ;initialize loop index
 099                   mult_loop: 
 099  1440E                       SR0 s4                         ;shift lsb to carry
 09A  3E09C                       JUMP NC, 09C[shift_prod]       ;lsb is 0
 09B  10530                       ADD s5, s3                     ;lsb is 1
 09C                  shift_prod: 
 09C  14508                       SRA s5                         ;shift upper byte right,
 09D                              ;carry to MSB, LSB to carry
 09D  14608                       SRA s6                         ;shift lower byte right,
 09E                              ;lsb of s5 to MSB of s6
 09E  19201                       SUB s2[i], 01                  ;dec loop index
 09F  36099                       JUMP NZ, 099[mult_loop]        ;repeat until i=0
 0A0  25000                       RETURN 
 0A1                              ;=========================================================
 0A1                              ;routine: display_mux_out
 0A1                              ;  function: generate enable pulse & led pattern
 0A1                              ;            for 4-digit 7-segment led display
 0A1                              ;  input register:
 0A1                              ;     count_msb, count_lsb: timer count
 0A1                              ;     led_pos: current led position
 0A1                              ;  output register:
 0A1                              ;     led_pos: updated led position
 0A1                              ;  tmp register: data, addr
 0A1                              ;=========================================================
 0A1             display_mux_out: 
 0A1  1DE02                       COMPARE sE[count_msb], 02      ;count=00000100_00000000
 0A2  3A0B8                       JUMP C, 0B8[mux_out_done]
 0A3                              ;clear time counter (count > 20)
 0A3  01F00                       LOAD sF[count_lsb], 00
 0A4  01E00                       LOAD sE[count_msb], 00
 0A5                              ;update 7-segment led position
 0A5  11B01                       ADD sB[led_pos], 01
 0A6  1DB04                       COMPARE sB[led_pos], 04
 0A7  360A9                       JUMP NZ, 0A9[gen_an_signal]
 0A8  01B00                       LOAD sB[led_pos], 00           ;led_pos wraps around
 0A9               gen_an_signal: 
 0A9                              ;generate 4-bit anode enable signal
 0A9  0100E                       LOAD s0[data], 0E              ;xxxx_1110
 0AA  1DB00                       COMPARE sB[led_pos], 00
 0AB  320B3                       JUMP Z, 0B3[shift_an_0]
 0AC  1DB01                       COMPARE sB[led_pos], 01
 0AD  320B2                       JUMP Z, 0B2[shift_an_1]
 0AE  1DB02                       COMPARE sB[led_pos], 02
 0AF  320B1                       JUMP Z, 0B1[shift_an_2]
 0B0  14007                       SL1 s0[data]                   ;shift 1110 3 times
 0B1                  shift_an_2: 
 0B1  14007                       SL1 s0[data]                   ;shift 1110 2 times
 0B2                  shift_an_1: 
 0B2  14007                       SL1 s0[data]                   ;shift 1110 1 times
 0B3                  shift_an_0: 
 0B3  2D000                       OUTPUT s0[data], 00[an_port]
 0B4                              ;output 7-seg led pattern
 0B4  01110                       LOAD s1[addr], 10[led0]
 0B5  101B0                       ADD s1[addr], sB[led_pos]
 0B6  0A010                       FETCH s0[data], (s1[addr])
 0B7  2D001                       OUTPUT s0[data], 01[sseg_port]
 0B8                mux_out_done: 
 0B8  25000                       RETURN 
 0B9                              ;=========================================================
 0B9                              ;routine: interrupt service routine
 0B9                              ;  function: increment 16-bit counter
 0B9                              ;  input register:
 0B9                              ;     count_msb, count_lsb: timer count
 0B9                              ;  output register:
 0B9                              ;     count_msb, count_lsb: incremented
 0B9                              ;=========================================================
 0B9         int_service_routine: 
 0B9  11F01                       ADD sF[count_lsb], 01          ;inc 16-bit counter
 0BA  13E00                       ADDCY sE[count_msb], 00
 0BB  29001                       RETURNI ENABLE
 0BC                              ;=========================================================
 0BC                              ;interrupt vector
 0BC                              ;=========================================================
 3FF                              ADDRESS 3FF
 3FF  220B9                       JUMP 0B9[int_service_routine]


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\ProjetosVHDL\KCPSM6\int_rom.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   14'd         
 timestamp_minutes 59'd         
 timestamp_seconds 39'd         
 datestamp_year    22'd         
 datestamp_month   8'd          
 datestamp_day     02'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 a_lsb             00           int_rom.psm
 b_lsb             02           int_rom.psm
 aa_lsb            04           int_rom.psm
 aa_msb            05           int_rom.psm
 bb_lsb            06           int_rom.psm
 bb_msb            07           int_rom.psm
 aabb_lsb          08           int_rom.psm
 aabb_msb          09           int_rom.psm
 aabb_cout         0A           int_rom.psm
 led0              10           int_rom.psm
 led1              11           int_rom.psm
 led2              12           int_rom.psm
 led3              13           int_rom.psm
 rd_flag_port      00           int_rom.psm
 sw_port           01           int_rom.psm
 an_port           00           int_rom.psm
 sseg_port         01           int_rom.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "02 Aug 2022"  
 timestamp$        "14:59:39"     



List of line labels

   Label                 Addr  Source PSM File

   forever               001   int_rom.psm
   init                  006   int_rom.psm
   clr_mem_loop          009   int_rom.psm
   proc_btn              011   int_rom.psm
   chk_btns              016   int_rom.psm
   proc_btn_done         01D   int_rom.psm
   load_led_pttn         01E   int_rom.psm
   sw_ok                 023   int_rom.psm
   led_done              03C   int_rom.psm
   hex_to_led            03E   int_rom.psm
   comp_hex_1            042   int_rom.psm
   comp_hex_2            046   int_rom.psm
   comp_hex_3            04A   int_rom.psm
   comp_hex_4            04E   int_rom.psm
   comp_hex_5            052   int_rom.psm
   comp_hex_6            056   int_rom.psm
   comp_hex_7            05A   int_rom.psm
   comp_hex_8            05E   int_rom.psm
   comp_hex_9            062   int_rom.psm
   comp_hex_a            066   int_rom.psm
   comp_hex_b            06A   int_rom.psm
   comp_hex_c            06E   int_rom.psm
   comp_hex_d            072   int_rom.psm
   comp_hex_e            076   int_rom.psm
   comp_hex_f            07A   int_rom.psm
   hex_done              07B   int_rom.psm
   get_lower_nibble      07C   int_rom.psm
   get_upper_nibble      07E   int_rom.psm
   square                083   int_rom.psm
   mult_soft             097   int_rom.psm
   mult_loop             099   int_rom.psm
   shift_prod            09C   int_rom.psm
   display_mux_out       0A1   int_rom.psm
   gen_an_signal         0A9   int_rom.psm
   shift_an_2            0B1   int_rom.psm
   shift_an_1            0B2   int_rom.psm
   shift_an_0            0B3   int_rom.psm
   mux_out_done          0B8   int_rom.psm
   int_service_routine   0B9   int_rom.psm



Instruction usage statistics

 Instruction    Instances

 LOAD             33
 STAR              -

 AND               2
 OR                -
 XOR               1

 ADD               9
 ADDCY             3
 SUB               2
 SUBCY             -

 TEST              3
 TESTCY            -
 COMPARE          22
 COMPARECY         -

 SL0               1
 SL1               3
 SLX               -
 SLA               -
 RL                -
 SR0               5
 SR1               -
 SRX               -
 SRA               2
 RR                -

 REGBANK           -

 INPUT             3
 OUTPUT            2
 OUTPUTK           -

 STORE            12
 FETCH            12

 DISABLE           -
 ENABLE            1
 RETURNI           1

 JUMP             46
 JUMP@             -
 CALL             16
 CALL@             -
 RETURN            9
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
