# -*- coding: utf-8 -*-
"""ProgFunc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cn_seZ553La8wPBiRfJbzQz6tGwBGLVe

# Programação Funcional

* Baseado em funções matemáticas 
  * Funções *definem* valores
  * Variáveis não são posições na memória
* Tendem a ser mais legíveis

# Tuplas

Uma tupla é um tipo composto que nos permite representar, valores estruturados, ou seja, uma combinação de mais de um valor elementar.

A representação de uma tupla é feita com a seguinte sintaxe: 
(t1, t2, t3, ..., tn)

```python
(27, 4, 2011)
('A', 'espada')
('hello', 22)
```
"""

def maiorQue(x, y): return (x, y, x > y)
maiorQue(1,3)

def divisaoInt(x, y): return (x//y, x%y)
divisaoInt(10,3)

"""Podemos ainda usar tuplas como parâmetros"""

from math import sqrt
def distancia(p1, p2):
  def prim(t): return t[0]
  def seg(t): return t[1]
  def dx(): return prim(p1) - prim(p2)
  def dy(): return seg(p1) - seg(p2)
  return sqrt(dx()**2 + dy()**2)
distancia((0,0),(3,4))

from math import sqrt
def distancia(p1, p2):
  def dx(): return p1[0] - p2[0]
  def dy(): return p1[1] - p2[1]
  return sqrt(dx()**2 + dy()**2)
distancia((0,0),(3,4))

"""# Listas

Vimos que as tuplas são agrupamentos de tamanhos pré-definidos e heterogêneos.

Em contrapartida, listas são tipos compostos para agrupar quantidades indefinidas de elementos de um mesmo tipo.

```python
[]
[1,2,3,4,5]
['a', 'e', 'i', 'o', 'u']
[(22,4,1500), (7,9,1822), (31,3,1964)]
[[1,2,5,10], [1,11], [1,2,3,4,6,12], [1,13], [1,2,7,14], [1,3,5,15]]
```
"""

[]
[1,2,3,4,5]
['a', 'e', 'i', 'o', 'u']
[(22,4,1500), (7,9,1822), (31,3,1964)]
[[1,2,5,10], [1,11], [1,2,3,4,6,12], [1,13], [1,2,7,14], [1,3,5,15]]

"""##Intervalo:

"""

# range(<num_de_elementos>) #{inicio em 0}
range(10)
list(range(10))

# range(<limite inferior>,<limite superior + 1>)
range(3,8)
list(range(3,8))

# range(<limite inferior>,<limite superior>,<razão>)
range(5,50,3)
list(range(5,50,3))

range(50,5,-3)
list(range(50,5,-3))

"""## Abrangência (Comprehension):"""

# [ <expressão> for <variável> in <lista> ]
[2*x for x in [0,1,2]]

# [ <expressão> for <variável> in <lista> for <variável> in <lista> ... ]
[x*y for x in [0,1,2] for y in [5,10]]

# [ <expressão> for <variável> in <lista> if <condição>] 
[2*x for x in [0,1,2] if x >= 1]

# <expressão> pode ser qualquer coisa que já aprendemos
# <lista> pode ser explicita, range or a comprehension
[(x, x**2) for x in range(1,9)]



[(x, y) for x in [1,2,3] for y in [-3,7,11]]

# is it the same x ???
[(x, x**2) for x in [2*x for x in [0,1,2]]]

# use of function
def f(x): return 2*x
[f(x) for x in range(1,9)]

"""## Operações básicas em LISTAS

**in** : avalia se um determinado elemento é membro de uma lista.

"""

# <elemento> in <lista>
3 in range(0,10,2)

"""**len**: descreve o tamanho de uma lista. """

# len(<lista>)
len([])

"""**indexação**: podemos acessar cada termo de uma lista indicando sua a posição dentro da lista, considerando que o primeiro elemento tem a ordem zero.

"""

# <lista> [<índice>]
range(3,20,4)[0]

# ultimo elemento pode ser obtido com -1
range(3,20,4)[-1]

# penultimo elemento pode ser obtido com -2 e assim por diante
range(3,20,4)[-2]

"""**sub-listas**: podemos descrever sublistas a partir de uma lista. Para tanto basta indicarmos a posição inicial e final da sub-lista, separadas pelo símbolo “:”"""

# <lista> [<índice inicial>:<índice final> +1] 
[1, 2, 3, 4, 5, 6, 7, 8, 9][1:4]

[1, 2, 3, 4, 5, 6, 7, 8, 9][:]

[1, 2, 3, 4, 5, 6, 7, 8, 9][1:]

[1, 2, 3, 4, 5, 6, 7, 8, 9][:4]

[1, 2, 3, 4, 5, 6, 7, 8, 9][-3:]

[1, 2, 3, 4, 5, 6, 7, 8, 9][:-3]

"""**concatenação**: descreve uma nova lista obtida pela concatenação de uma lista de listas."""

# <lista> + <lista>
[1,2,3] + [4,5]

list(range(1,6)) + list(range(4,0,-1))

"""**map**

O resultado é uma lista obtida aplicando-se a função a cada elemento da lista.
"""

# map( função,  lista ) -> lista

def f(x): return 2*x
map(f, range(1,6))
list(map(f, range(1,6)))

# equivalente com comprehension
[2*x for x in range(1,6)]

"""**filter**

A lista resultante são os elementos para os quais a função é verdadeira.
"""

# filter( função,  lista ) -> lista
def f(x): return x%2==0
filter(f, range(1,6))
list(filter(f, range(1,6)))

# equivalente com comprehension
[x for x in range(1,6) if x%2==0]

"""**reduce**

Resultado é a aplicação acumulativa da função aos elementos da lista

"""

# reduce( função,  lista ) -> valor
from functools import reduce
def f(x,y): return x+y
reduce(f, range(1,6))

# Reduce( função, lista, valorInicial ) -> valor
reduce(f, range(1,6),50)

# equivalente com recursão
def myReduce(f, l, i=None):
  if len(l) > 1:
    return f(l[0], myReduce(f, l[1:], i))
  else:
    return l[0] if i==None else f(l[0],i)
myReduce(f, range(1,6), 50)

"""**lambda**

Uma expressão lambda permite escrever funções anônimas.
"""

# lambda p1, p2, ..., pn: expressão
map(lambda x: 2*x, range(1,6))
list(map(lambda x: 2*x, range(1,6)))

filter(lambda x: x%2==0, range(1,6))
list(filter(lambda x: x%2==0, range(1,6)))

reduce(lambda x, y: x+y, range(1,6))

"""**zip**

O resultado é uma lista de enuplas formadas pelos elementos de mesma ordem de cada lista
"""

# zip( lista1, lista2, ...., lista-n ) -> lista-enuplas
list(zip(range(1,6), range(2,7), range(3,8)))

list(zip([1,2,9], [3,4], [5,6]))

# equivalente com comprehension
def myZip(l1, l2, l3):
  return [(l1[i], l2[i], l3[i]) for i in range(min(len(l1), len(l2), len(l3)))]
myZip(range(1,6), range(2,7), range(3,8))

"""# Extras:

## **Map** com mais de uma lista
Semelhante ao zip, porem mais robusto
"""

list(map(lambda x, y, z:(x,y,z) , range(1,6), range(2,7), range(3,8)))

list(map(lambda x, y, z:(2*x,3*y,4*z) , range(1,6), range(2,7), range(3,8)))

"""## Módulo de testes

Python provê uma forma interessante de testar se seu programa produz o resultado esperado. Quando os testes sao bem planejados, é uma forma interessante de saber se seu programa tem algum bug. 
"""

# exemplo de como usar o modulo de testes testmod

from doctest import testmod

def myReduce(f, l, i=None):
  """
    Essa função simula o reduce com recursão
    TESTES:
    >>> myReduce(lambda x,y: x+y, []) # lista vazia retorna None para qualquer funcao
    
    >>> myReduce(lambda x,y: x*y, []) # lista vazia retorna None para qualquer funcao
    
    >>> myReduce(lambda x,y: x+y, range(1,6)) # teste basico com soma
    15
    >>> myReduce(lambda x,y: x+y, range(1,6),0) # teste do valor inicial => 0 na soma teria que manter o valor anterior
    15
    >>> myReduce(lambda x,y: x+y, range(1,6),50) # teste do valor inicial => 50 na soma teria que manter o valor anterior + 50
    65
    >>> myReduce(lambda x,y: x*y, range(1,6)) # teste basico com produto
    120
    >>> myReduce(lambda x,y: x*y, range(1,6),1) # teste do valor inicial => 1 teria que manter o valor anterior
    120
    >>> myReduce(lambda x,y: x*y, range(1,6),10) # teste do valor inicial => 10 teria que manter o valor anterior vezes 10
    1200
    >>> myReduce(lambda x,y: x*y, range(1,6),0) # teste do valor inicial => 0 no produto teria que dar 0
    0
  """   
  if len(l) > 1:
    return f(l[0], myReduce(f, l[1:], i))
  elif len(l) == 1:
    return l[0] if i==None else f(l[0],i)
  else:
    return None

testmod()
# myReduce(lambda x,y: x+y, [1]) # teste basico com soma

[ (x, y) for x in range(5) for y in map(lambda z: 2*z, [x]) if y != 2 ]

filtered_data = [y for x in data if (y := f(x)) is not None]